<?php

/**
 * @file
 * EGIR OS2forms.
 */

use Drupal\maestro\Engine\MaestroEngine;
use Drupal\webform\Entity\WebformSubmission;
use Drupal\user\Entity\User;
use Ramsey\Uuid\Uuid;

require 'EGIRConfig.php';
require 'gir_utils.php';

/**
 * Handler that returns an Array of function names and help text.
 *
 * These will be displayed in the edit task form under the handler field.
 */
function os2forms_forloeb_maestro_interactive_handlers() {
  return [
    'os2forms_forloeb_workflow_maestro_reassign_form' => t('TilfÃ¸j sagsbehandler'),
    'os2forms_forloeb_show_url_results' => t('Test URL fetch - requires process variables from that handler'),
  ];
}

/**
 * The Reassign for Approval form used in maestro workflows.
 *
 * @param array $form
 *   The array that contains the form.
 * @param object $obj
 *   References the calling object.
 * @param int $queueID
 *   The queueID from Maestro.
 */
function os2forms_forloeb_workflow_maestro_reassign_form(array &$form, $obj, $queueID = 0) {

  $form['reviewer'] = [
    '#id' => 'select_assigned_user',
    '#type' => 'entity_autocomplete',
    '#target_type' => 'user',
    '#default_value' => '',
    '#selection_settings' => ['include_anonymous' => FALSE],
    '#title' => t('Assign for Review to'),
  ];

  $form['queueID'] = [
    '#type' => 'hidden',
    '#title' => 'the queue ID in the event we need it in later processing',
    '#default_value' => $queueID,
    '#description' => ('queueID'),
  ];

  // Overriding the default label "complete".
  $form['actions']['submit']['#value'] = t('Assign');

  return $form;
}

/**
 * Simple batch handler to display the result of calling an external URL.
 *
 * Requires two process variables, 'url_status' and 'url_body', and
 * requires the batch function calling the URL to set these variables.
 *
 * @param array $form
 *   The form you will create with this function.
 * @param int $queueID
 *   The ID of the queue task ID you are executing.
 */
function os2forms_forloeb_show_url_results(array &$form, $queueID = 0, $obj = NULL) {
  $form['queueID'] = [
    '#type' => 'hidden',
    '#title' => 'Hidden Queue ID',
    '#default_value' => $queueID,
    '#description' => ('queueID'),
  ];

  $processID = MaestroEngine::getProcessIdFromQueueId($queueID);
  $url_status = MaestroEngine::getProcessVariable('url_status', $processID);
  $url_body = MaestroEngine::getProcessVariable('url_body', $processID);
  if ($url_status === FALSE) {
    $message = 'No process variable called message defined for this workflow template';
  }

  $form['url_status'] = [
    '#plain_text' => $url_status,
    '#suffix' => '<br>',
  ];

  $form['url_body'] = [
    '#plain_text' => $url_body,
    '#suffix' => '<br>',
  ];

  return $form;
}

/**
 * Submit handler for the Reassign for Approval form use in maestro workflows.
 */
function os2forms_forloeb_workflow_maestro_reassign_form_submit(&$form, &$form_state) {

  $queueID = intval($form_state->getValue('queueID'));
  $processID = MaestroEngine::getProcessIdFromQueueId($queueID);

  // Who was selected?
  // Load username, which is the user attribute that Maestro assigns tasks by.
  $reviewer_uid = $form_state->getValue('reviewer');
  // Pass your uid.
  $reviewer = User::load($reviewer_uid);
  $reviewer_username = $reviewer->getUsername();

  // Add that user to our maestro process variable.
  MaestroEngine::setProcessVariable("assigned_to", $reviewer_username, $processID);

  // Provide some feedback.
  \Drupal::messenger()->addStatus("Content Reassigned");
}

/**
 * Implements hook_maestro_batch_handlers().
 *
 * Array of function names and help text that will be displayed
 * in the edit task form under the handler field.
 */
function os2forms_forloeb_maestro_batch_handlers() {
  return [
    'os2forms_forloeb_end_notification_batch_function' => t('Batch function to send out flow completion notification to initiator.'),
    'os2forms_forloeb_fetch_from_http_endpoint_batch_function' => t('Batch function to fetch data from an external HTTP endpoint. Returns data in two process variables, url_status and url_body.'),
    'os2forms_forloeb_gir_create_org_unit' => t('Batch function to create a new org unit in GIR.'),
    'os2forms_forloeb_gir_change_org_unit' => t('Batch function to change an org unit in GIR.'),
    'os2forms_forloeb_gir_disable_org_unit' => t('Batch function to disable an org unit in GIR.'),
    'os2forms_forloeb_gir_create_external' => t('Batch function to create a new external employee in GIR.'),
    'os2forms_forloeb_gir_change_external' => t('Batch function to change an external employee in GIR.'),
    'os2forms_forloeb_gir_disable_external' => t('Batch function to disable an external employee in GIR.'),
    'os2forms_forloeb_gir_move_many_externals' => t('Batch function to move several external employees from one unit to another.'),
    'os2forms_forloeb_gir_approver_is_initiator' => t('Batch function to compare approver and initiator of a submission'),
  ];
}

/**
 * Notification batch function.
 *
 * @param int $processID
 *   The Maestro process ID.
 * @param int $queueID
 *   The Maestro queue ID.
 */
function os2forms_forloeb_end_notification_batch_function($processID, $queueID) {

  /*
   * Pseudocode for handling this:
   *
   *     * Get entity item for webform which spawned this process
   *      (ID "submission").
   *       foreach handler in webform: {
   *           if (email_handler) {
   *               email_handler.submit();
   *           }
   *       }
   */
  $sid = MaestroEngine::getEntityIdentiferByUniqueID($processID, 'submission');

  if ($sid) {
    $webform_submission = WebformSubmission::load($sid);
    $webform = $webform_submission->getWebform();
    $handlers = $webform->getHandlers();

    foreach ($handlers as $handler) {
      if (method_exists($handler, 'getMessage')) {
        $message = $handler->getMessage($webform_submission);
        $handler->sendMessage($webform_submission, $message);
      }
    }
  }

  return TRUE;
}

/**
 * Fetch from HTTP endpoint batch function.
 */
function os2forms_forloeb_fetch_from_http_endpoint_batch_function($processID, $queueID) {

  // @todo get URL from process variable.
  $url = MaestroEngine::getProcessVariable('url', $processID);

  $response = \Drupal::httpClient()->get($url);
  $status_code = $response->getStatusCode();
  if ($status_code == 200) {
    $body = $response->getBody();
  }
  else {
    $body = '';
  }

  MaestroEngine::setProcessVariable('url_status', $status_code, $processID);
  MaestroEngine::setProcessVariable('url_body', $body, $processID);

  return TRUE;
}

/**
 * Determine whether the initiator of a process is also the approver.
 */
function os2forms_forloeb_gir_approver_is_initiator($processID, $queueID) {
  // It would be nice to be able to handle this in an IF task,
  // but these only allow you to compare a process variable to a constant value.
  // This function will succeed if the approver is initiator and fail otherwise.
  // This means that it can be combined with an IF task set up to branch
  // according to the result of the preceding task.
  $initiator = MaestroEngine::getProcessVariable('initiator', $processID);
  $approver = MaestroEngine::getProcessVariable('approver', $processID);

  \Drupal::logger('os2forms_forloeb')->notice('initiator: ' . $initiator . ', approver: ' . $approver);
  if ($initiator === $approver) {
    // S'all good, man!
    return TRUE;
  }
  else {
    \Drupal::logger('os2forms_forloeb')->notice('Cancelling task!');
    return [
      'execution_status' => TASK_STATUS_CANCEL,
      'completion_status' => MAESTRO_TASK_COMPLETION_NORMAL,
      'status' => TRUE,
    ];
  }
}

/**
 * Change org unit.
 */
function os2forms_forloeb_gir_change_org_unit($processID, $queueID) {
  // @todo Implement this.
  return TRUE;
}

/**
 * Change external.
 */
function os2forms_forloeb_gir_change_external($processID, $queueID) {
  // @todo Implement this.
  return TRUE;
}

/**
 * Disable org unit.
 */
function os2forms_forloeb_gir_disable_org_unit($processID, $queueID) {
  // @todo Implement this.
  return TRUE;
}

/**
 * Disable external.
 */
function os2forms_forloeb_gir_disable_external($processID, $queueID) {
  // @todo Implement this.
  return TRUE;
}

/**
 * Create organisation unit.
 */
function os2forms_forloeb_gir_create_org_unit($processID, $queueID) {
  // Get ID for webform which spawned this process.
  $sid = MaestroEngine::getEntityIdentiferByUniqueID($processID, 'submission');
  if ($sid) {

    $webform_submission = WebformSubmission::load($sid);
    // cf.
    // https://www.drupal.org/project/webform/issues/2911356#comment-12271553
    $values = $webform_submission->getData();

    // Org data.
    $name = $values['name'];

    // @todo Fix address data.
    $address = NULL;

    // Validity data.
    $start_date = $values['start_date'];
    $end_date = $values['end_date'] !== '' ? $values['end_date'] : NULL;

    $owner_id = $values['owner'];
  }
  else {
    return FALSE;
  }

  // Get config.
  $config = new EGIRConfig();

  // Validity.
  $validity = ['from' => $start_date, 'to' => $end_date];

  // Owner data.
  $owner_uuid = get_user_data($owner_id, 'field_uuid');
  $owner_details = [
    'type' => 'owner',
    'owner' => ['uuid' => $owner_uuid],
    'validity' => $validity,
  ];

  // Full OU data.
  $ou_data = [
    'name' => $name,
    'user_key' => $name,
    'validity' => $validity,
    'parent' => ['uuid' => $config->extOUParent],
    'org_unit_type' => ['uuid' => $config->extOUType],
    'org_unit_level' => ['uuid' => $config->extOULevel],
    'details' => [$owner_details],
  ];

  $json_data = json_encode($ou_data);
  forms_log()->notice('Org unit sent: <' . $json_data . '>');

  $resp = post_json_to_api('/service/ou/create', $json_data);

  if ($resp->getStatusCode() === 201) {
    $url_status = 'Success';
    $url_body = 'Organisation unit ' . $name . ' was successfully created.';
  }
  else {
    $url_status = 'Failed';
    $err_msg = json_decode($resp->getBody(), TRUE)['description'] ?? 'No description';
    $url_body = 'Unable to create organisation unit ' . $name . ': ' . $err_msg;
  };

  MaestroEngine::setProcessVariable('url_status', $url_status, $processID);
  MaestroEngine::setProcessVariable('url_body', $url_body, $processID);

  return TRUE;
}

/**
 * Create externals.
 */
function os2forms_forloeb_gir_create_external($processID, $queueID) {
  // Get ID for webform which spawned this process.
  $sid = MaestroEngine::getEntityIdentiferByUniqueID($processID, 'submission');
  if ($sid) {

    $webform_submission = WebformSubmission::load($sid);
    // cf.
    // https://www.drupal.org/project/webform/issues/2911356#comment-12271553
    $values = $webform_submission->getData();

    // Employee data.
    $first_name = $values['first_name'];
    $last_name = $values['last_name'];
    $email = $values['email_address'];
    $phone = $values['telephone_number'];

    // Consultancy data.
    $consultancy_id = $values['consultancy'];
    $consultant_type_id = $values['consultant_type'];
    $cost_center_id = $values['cost_center'];
    // array_filter($array, 'strlen') removes NULL, FALSE, and empty strings.
    // We want to implode location later, so this comes in handy.
    $location = array_filter($values['location'], 'strlen');
    $org_units = $values['organisational_unit'];
    $start_date = $values['start_date'];
    $end_date = $values['end_date'] !== '' ? $values['end_date'] : NULL;
  }
  else {
    return FALSE;
  }

  // Get config.
  $config = new EGIRConfig();

  // Validity.
  $validity = ['from' => $start_date, 'to' => $end_date];

  // Get consultancy data MO UUIDs.
  $consultancy_uuid = get_term_data($consultancy_id, 'field_uuid');
  $consultant_type_uuid = get_term_data($consultant_type_id, 'field_uuid');
  $cost_center_uuid = get_term_data($cost_center_id, 'field_uuid');

  // Generate employment UUID.
  $employment_uuid = Uuid::uuid4()->toString();

  // Array for details.
  $details = [];
  array_push($details,
    // Employment.
    [
      'type' => 'engagement',
      'uuid' => $employment_uuid,
      'org_unit' => ['uuid' => $consultancy_uuid],
      'job_function' => ['uuid' => $config->extJobFunction],
      'engagement_type' => ['uuid' => $consultant_type_uuid],
      'validity' => $validity,
      'primary' => ['uuid' => $config->primaryType],
    ],
    // Cost center engagement association.
    [
      'type' => 'engagement_association',
      'org_unit' => ['uuid' => $cost_center_uuid],
      'engagement' => ['uuid' => $employment_uuid],
      'engagement_association_type' => ['uuid' => $config->costcenterEA],
      'validity' => $validity,
    ],
    // Addresses.
    [
      'type' => 'address',
      'value' => $email,
      'address_type' => ['uuid' => $config->extEmailType],
      'validity' => $validity,
    ],
    [
      'type' => 'address',
      'value' => $phone,
      'address_type' => ['uuid' => $config->extPhoneType],
      'validity' => $validity,
    ],
    [
      'type' => 'address',
      'value' => implode(", ", $location),
      'address_type' => ['uuid' => $config->extLocationType],
      'validity' => $validity,
    ]
  );

  // Remaining engagement associations.
  foreach ($org_units as $ou) {
    $ou_uuid = get_term_data($ou, 'field_uuid');
    array_push($details,
      [
        'type' => 'engagement_association',
        'org_unit' => ['uuid' => $ou_uuid],
        'engagement' => ['uuid' => $employment_uuid],
        'engagement_association_type' => ['uuid' => $config->externalEA],
        'validity' => $validity,
      ]
    );
  }

  $external_data = [
    'givenname' => $first_name,
    'surname' => $last_name,
    'seniority' => $start_date,
    'details' => $details,
  ];

  $json_data = json_encode($external_data);
  forms_log()->notice('External sent: <' . $json_data . '>');

  // Param ?force=true is required because we create engagements and
  // engagement associations, which are interdependent, at the same time.
  $resp = post_json_to_api('/service/e/create?force=true', $json_data);

  if ($resp->getStatusCode() === 201) {
    $url_status = 'Success';
    $url_body = 'Employee ' . $first_name . ' '
      . $last_name . ' was successfully created.';
  }
  else {
    $url_status = 'Failed';
    $err_msg = json_decode($resp->getBody(), TRUE)['description'] ?? 'No description';
    $url_body = 'Unable to create external '
      . $first_name . ' ' . $last_name . ': ' . $err_msg;
  };

  MaestroEngine::setProcessVariable('url_status', $url_status, $processID);
  MaestroEngine::setProcessVariable('url_body', $url_body, $processID);

  return TRUE;
}

/**
 * Set Process Variable (SPV) function.
 *
 * Uses the webform's unique identifier referenced in the Maestro "webforms"
 * process variable to read a value from the webform submission and return it
 * to the SPV task to set the process variable in the task.
 * The function assumes that the value to be extracted is the SID of a user
 * and returns the username instead.
 * This seems to be the easiest way to accomplish this.
 *
 * The "webforms" process variable is set by the Maestro Webforms
 * submission handler which sets a "submission:xxx" value
 * in the "webforms" process variable, where "xxx" is the unique ID
 * of the submission, or is set by the Maestro Webform Task Type's
 * "Unique Identifier" setting when editing a Maestro Webform Task.
 *
 * @param string $uniqueWebformIdentifier
 *   The webform's "Unique Identifier" as stored
 *    in the "webforms" process variable.
 * @param string $webformFieldMachineName
 *   The webform field's machine name
 *    (listed as "KEY" in the webform builder) you wish to pull the value from.
 * @param int $queueID
 *   Provided by the executing SPV task -- the QueueID of the SPV task.
 * @param int $processID
 *   Provided by the executing SPV task -- the ProcessID of the workflow
 *    running the SPV task.
 */
function os2forms_forloeb_spv_fetch_entity_username($uniqueWebformIdentifier, $webformFieldMachineName, $queueID, $processID) {
  $returnValue = 'unset';
  // This is the submission we're eventually after.
  $sid = FALSE;
  $sid = MaestroEngine::getEntityIdentiferByUniqueID($processID, $uniqueWebformIdentifier);
  if ($sid) {
    $webform_submission = WebformSubmission::load($sid);
  }
  if ($webform_submission && array_key_exists($webformFieldMachineName, $webform_submission->getData())) {
    $returnValue = $webform_submission->getData()[$webformFieldMachineName];
  }
  // At this point, the submission's value OR 'unset' is in the $returnValue.
  if ($returnValue == 'unset' or !$returnValue) {
    return $returnValue;
  }
  $account = User::load($returnValue);
  $username = $account->getUsername();
  return $username;
}
