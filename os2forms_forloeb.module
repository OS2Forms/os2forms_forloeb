<?php

/**
 * @file
 * EGIR OS2forms.
 */

use Drupal\maestro\Engine\MaestroEngine;
use Drupal\webform\Entity\WebformSubmission;
use Drupal\user\Entity\User;

require 'src/gir_utils.php';

/**
 * Handler that returns an Array of function names and help text.
 *
 * These will be displayed in the edit task form under the handler field.
 */
function os2forms_forloeb_maestro_interactive_handlers() {
  return [
    'os2forms_forloeb_workflow_maestro_reassign_form' => t('TilfÃ¸j sagsbehandler'),
    'os2forms_forloeb_show_url_results' => t('Test URL fetch - requires process variables from that handler'),
  ];
}

/**
 * The Reassign for Approval form used in maestro workflows.
 *
 * @param array $form
 *   The array that contains the form.
 * @param object $obj
 *   References the calling object.
 * @param int $queueID
 *   The queueID from Maestro.
 */
function os2forms_forloeb_workflow_maestro_reassign_form(array &$form, $obj, $queueID = 0) {

  $form['reviewer'] = [
    '#id' => 'select_assigned_user',
    '#type' => 'entity_autocomplete',
    '#target_type' => 'user',
    '#default_value' => '',
    '#selection_settings' => ['include_anonymous' => FALSE],
    '#title' => t('Assign for Review to'),
  ];

  $form['queueID'] = [
    '#type' => 'hidden',
    '#title' => 'the queue ID in the event we need it in later processing',
    '#default_value' => $queueID,
    '#description' => ('queueID'),
  ];

  // Overriding the default label "complete".
  $form['actions']['submit']['#value'] = t('Assign');

  return $form;
}

/**
 * Simple batch handler to display the result of calling an external URL.
 *
 * Requires two process variables, 'url_status' and 'url_body', and
 * requires the batch function calling the URL to set these variables.
 *
 * @param array $form
 *   The form you will create with this function.
 * @param int $queueID
 *   The ID of the queue task ID you are executing.
 */
function os2forms_forloeb_show_url_results(array &$form, $queueID = 0, $obj = NULL) {
  $form['queueID'] = [
    '#type' => 'hidden',
    '#title' => 'Hidden Queue ID',
    '#default_value' => $queueID,
    '#description' => ('queueID'),
  ];

  $processID = MaestroEngine::getProcessIdFromQueueId($queueID);
  $url_status = MaestroEngine::getProcessVariable('url_status', $processID);
  $url_body = MaestroEngine::getProcessVariable('url_body', $processID);
  if ($url_status === FALSE) {
    $message = 'No process variable called message defined for this workflow template';
  }

  $form['url_status'] = [
    '#plain_text' => $url_status,
    '#suffix' => '<br>',
  ];

  $form['url_body'] = [
    '#plain_text' => $url_body,
    '#suffix' => '<br>',
  ];

  return $form;
}

/**
 * Submit handler for the Reassign for Approval form use in maestro workflows.
 */
function os2forms_forloeb_workflow_maestro_reassign_form_submit(&$form, &$form_state) {

  $queueID = intval($form_state->getValue('queueID'));
  $processID = MaestroEngine::getProcessIdFromQueueId($queueID);

  // Who was selected?
  // Load username, which is the user attribute that Maestro assigns tasks by.
  $reviewer_uid = $form_state->getValue('reviewer');
  // Pass your uid.
  $reviewer = User::load($reviewer_uid);
  $reviewer_username = $reviewer->getUsername();

  // Add that user to our maestro process variable.
  MaestroEngine::setProcessVariable("assigned_to", $reviewer_username, $processID);

  // Provide some feedback.
  \Drupal::messenger()->addStatus("Content Reassigned");
}

/**
 * Implements hook_maestro_batch_handlers().
 *
 * Array of function names and help text that will be displayed
 * in the edit task form under the handler field.
 */
function os2forms_forloeb_maestro_batch_handlers() {
  return [
    'os2forms_forloeb_end_notification_batch_function' => t('Batch function to send out flow completion notification to initiator.'),
    'os2forms_forloeb_fetch_from_http_endpoint_batch_function' => t('Batch function to fetch data from an external HTTP endpoint. Returns data in two process variables, url_status and url_body.'),
    'os2forms_forloeb_gir_create_org_unit' => t('Batch function to create a new org unit in GIR.'),
    'os2forms_forloeb_gir_change_org_unit' => t('Batch function to change an org unit in GIR.'),
    'os2forms_forloeb_gir_disable_org_unit' => t('Batch function to disable an org unit in GIR.'),
    'os2forms_forloeb_gir_create_external' => t('Batch function to create a new external employee in GIR.'),
    'os2forms_forloeb_gir_change_external' => t('Batch function to change an external employee in GIR.'),
    'os2forms_forloeb_gir_disable_external' => t('Batch function to disable an external employee in GIR.'),
    'os2forms_forloeb_gir_approver_is_initiator' => t('Batch function to compare approver and initiator of a submission'),
  ];
}

/**
 * Notification batch function.
 *
 * @param int $processID
 *   The Maestro process ID.
 * @param int $queueID
 *   The Maestro queue ID.
 */
function os2forms_forloeb_end_notification_batch_function($processID, $queueID) {

  /*
   * Pseudocode for handling this:
   *
   *     * Get entity item for webform which spawned this process
   *      (ID "submission").
   *       foreach handler in webform: {
   *           if (email_handler) {
   *               email_handler.submit();
   *           }
   *       }
   */
  $sid = MaestroEngine::getEntityIdentiferByUniqueID($processID, 'submission');

  if ($sid) {
    $webform_submission = WebformSubmission::load($sid);
    $webform = $webform_submission->getWebform();
    $handlers = $webform->getHandlers();

    foreach ($handlers as $handler) {
      if (method_exists($handler, 'getMessage')) {
        $message = $handler->getMessage($webform_submission);
        $handler->sendMessage($webform_submission, $message);
      }
    }
  }

  return TRUE;
}

/**
 * Fetch from HTTP endpoint batch function.
 */
function os2forms_forloeb_fetch_from_http_endpoint_batch_function($processID, $queueID) {

  // @todo get URL from process variable.
  $url = MaestroEngine::getProcessVariable('url', $processID);

  $response = \Drupal::httpClient()->get($url);
  $status_code = $response->getStatusCode();
  if ($status_code == 200) {
    $body = $response->getBody();
  }
  else {
    $body = '';
  }

  MaestroEngine::setProcessVariable('url_status', $status_code, $processID);
  MaestroEngine::setProcessVariable('url_body', $body, $processID);

  return TRUE;
}

/**
 * Determine whether the initiator of a process is also the approver.
 */
function os2forms_forloeb_gir_approver_is_initiator($processID, $queueID) {
  // It would be nice to be able to handle this in an IF task,
  // but these only allow you to compare a process variable to a constant value.
  // This function will succeed if the approver is initiator and fail otherwise.
  // This means that it can be combined with an IF task set up to branch
  // according to the result of the preceding task.
  $initiator = MaestroEngine::getProcessVariable('initiator', $processID);
  $approver = MaestroEngine::getProcessVariable('approver', $processID);

  \Drupal::logger('os2forms_forloeb')->notice('initiator: ' . $initiator . ', approver: ' . $approver);
  if ($initiator === $approver) {
    // S'all good, man!
    return TRUE;
  }
  else {
    \Drupal::logger('os2forms_forloeb')->notice('Cancelling task!');
    return [
      'execution_status' => TASK_STATUS_CANCEL,
      'completion_status' => MAESTRO_TASK_COMPLETION_NORMAL,
      'status' => TRUE,
    ];
  }
}

/**
 * Change org unit.
 */
function os2forms_forloeb_gir_change_org_unit($processID, $queueID) {
  // @todo Implement this.
  return TRUE;
}

/**
 * Change external.
 */
function os2forms_forloeb_gir_change_external($processID, $queueID) {
  // @todo Implement this.
  return TRUE;
}

/**
 * Disable org unit.
 */
function os2forms_forloeb_gir_disable_org_unit($processID, $queueID) {
  // @todo Implement this.
  return TRUE;
}

/**
 * Disable external.
 */
function os2forms_forloeb_gir_disable_external($processID, $queueID) {
  // @todo Implement this.
  return TRUE;
}

/**
 * Create organisation unit.
 */
function os2forms_forloeb_gir_create_org_unit($processID, $queueID) {
  // Get ID for webform which spawned this process.
  $sid = MaestroEngine::getEntityIdentiferByUniqueID($processID, 'submission');
  if ($sid) {

    $webform_submission = WebformSubmission::load($sid);
    // cf.
    // https://www.drupal.org/project/webform/issues/2911356#comment-12271553
    $values = $webform_submission->getData();

    // Org data.
    $name = $values['name'];
    $parent_unit_id = get_externals_parent();
    // @todo Fix address data.
    $start_date = $values['start_date'];
    $_end = $values['end_date'];

    // Sending empty strings will fail.
    $end_date = $_end !== '' ? $_end : NULL;

    // Approval information.
    $time_limit = $values['time_limit'];
    $justification = $values['justification'];

    // Extract MO UUIDs for these entities.
    $approver = $values['approver'];
    $owner_id = $values['owner'];
  }
  else {
    return FALSE;
  }

  \Drupal::logger('os2forms_forloeb')->notice('Owner: ' . $owner_id);

  // Get org unit type from data.
  $ou_type_items = get_json_from_api('/service/f/org_unit_type/')['data']['items'];
  $ou_type_id = NULL;

  foreach ($ou_type_items as $item) {
    if ($item['user_key'] === 'External') {
      $ou_type_id = $item['uuid'];
      break;
    }
  }

  // @todo Org unit level should come from user data as well,
  // since there will probably be more than one
  $ou_level_items = get_json_from_api('/service/f/org_unit_level/')['data']['items'];
  $ou_level_id = NULL;

  foreach ($ou_level_items as $item) {
    if ($item['user_key'] === 'L0') {
      $ou_level_id = $item['uuid'];
      break;
    }
  }
  // Parse owners.
  $owner_term = \Drupal::entityTypeManager()->getStorage('user')->load($owner_id);

  $ou_data = [
    'name' => $name,
    'user_key' => $name,
    'validity' => ['from' => $start_date, 'to' => $end_date],
    'parent' => ['uuid' => $parent_unit_id],
    'org_unit_type' => ['uuid' => $ou_type_id],
    'org_unit_level' => ['uuid' => $ou_level_id],
  ];

  $json_data = json_encode($ou_data);

  $resp = post_json_to_api('/service/ou/create', $json_data);

  if ($resp->getStatusCode() === 201) {
    $url_status = 'Success';
    $url_body = 'Organisation unit ' . $name . ' was successfully created.';
  }
  else {
    $url_status = 'Failed';
    $err_msg = json_decode($resp->getBody(), TRUE)['description'];
    $url_body = 'Unable to create organisation unit ' . $name . ': ' . $err_msg;
    return FALSE;
  };

  MaestroEngine::setProcessVariable('url_status', $url_status, $processID);
  MaestroEngine::setProcessVariable('url_body', $url_body, $processID);

  return TRUE;
}

/**
 * Create externals.
 */
function os2forms_forloeb_gir_create_external($processID, $queueID) {

  // Get GIR URL from process variable.
  $url = get_gir_url();

  $create_url = $url . '/service/e/create';

  // Get ID for webform which spawned this process.
  $sid = MaestroEngine::getEntityIdentiferByUniqueID($processID, 'submission');
  if ($sid) {

    $webform_submission = WebformSubmission::load($sid);
    // cf.
    // https://www.drupal.org/project/webform/issues/2911356#comment-12271553
    $values = $webform_submission->getData();

    // Employee Data.
    $first_name = $values['first_name'];
    $last_name = $values['last_name'];
    // @todo Format data with MO UUIDs for consultancy, consultant
    // type, cost center and org units.
    $start_date = $values['start_date'];
    $end_date = $values['end_date'];

    // Approval information.
    // $time_limit = $values['time_limit'];
    // $justification = $values['justification'];
    // Extract MO UUIDs for these entities.
    // $approver = $values['approver'];
    // $owner = $values['owner'];
  }
  else {
    return FALSE;
  }
  $gir_json = new \stdClass();
  $gir_json->givenname = $first_name;
  $gir_json->surname = $last_name;

  $gir_json->validity = new \stdClass();
  $gir_json->validity->from = $start_date;
  if ($end_date) {
    $gir_json->validity->to = $end_date;
  }

  $post_data = json_encode($gir_json);
  \Drupal::logger('os2forms_forloeb')->notice('Employee JSON sent: ' . '<' . $post_data . '>');

  // Get access token for authentication.
  $access_token = get_openid_auth_token();
  $headers = [
    'Authorization' => 'Bearer ' . $access_token,
    'Accept' => 'application/json',
    'content-type' => 'application/json',
  ];

  try {
    $response = \Drupal::httpClient()->request(
      'POST',
      $create_url,
      ['body' => $post_data, 'headers' => $headers]
    );
  }
  catch (GuzzleHttp\Exception\BadResponseException $e) {
    $response = $e->getResponse();
  }

  $status_code = $response->getStatusCode();
  if ($status_code == 201) {
    $url_status = "Success";
    $url_body = "Employee " . $first_name . " " . $last_name . " was created.";
  }
  else {
    $body = $response->getBody();
    $url_status = "Failed";
    $url_body = "Unable to create external " . $first_name . ": " . $body;
  }

  MaestroEngine::setProcessVariable('url_status', $url_status, $processID);
  MaestroEngine::setProcessVariable('url_body', $url_body, $processID);

  return TRUE;
}

/**
 * Set Process Variable (SPV) function.
 *
 * Uses the webform's unique identifier referenced in the Maestro "webforms"
 * process variable to read a value from the webform submission and return it
 * to the SPV task to set the process variable in the task.
 * The function assumes that the value to be extracted is the SID of a user
 * and returns the username instead.
 * This seems to be the easiest way to accomplish this.
 *
 * The "webforms" process variable is set by the Maestro Webforms
 * submission handler which sets a "submission:xxx" value
 * in the "webforms" process variable, where "xxx" is the unique ID
 * of the submission, or is set by the Maestro Webform Task Type's
 * "Unique Identifier" setting when editing a Maestro Webform Task.
 *
 * @param string $uniqueWebformIdentifier
 *   The webform's "Unique Identifier" as stored
 *    in the "webforms" process variable.
 * @param string $webformFieldMachineName
 *   The webform field's machine name
 *    (listed as "KEY" in the webform builder) you wish to pull the value from.
 * @param int $queueID
 *   Provided by the executing SPV task -- the QueueID of the SPV task.
 * @param int $processID
 *   Provided by the executing SPV task -- the ProcessID of the workflow
 *    running the SPV task.
 */
function os2forms_forloeb_spv_fetch_entity_username($uniqueWebformIdentifier, $webformFieldMachineName, $queueID, $processID) {
  $returnValue = 'unset';
  // This is the submission we're eventually after.
  $sid = FALSE;
  $sid = MaestroEngine::getEntityIdentiferByUniqueID($processID, $uniqueWebformIdentifier);
  if ($sid) {
    $webform_submission = WebformSubmission::load($sid);
  }
  if ($webform_submission && array_key_exists($webformFieldMachineName, $webform_submission->getData())) {
    $returnValue = $webform_submission->getData()[$webformFieldMachineName];
  }
  // At this point, the submission's value OR 'unset' is in the $returnValue.
  if ($returnValue == 'unset' or !$returnValue) {
    return $returnValue;
  }
  $account = User::load($returnValue);
  $username = $account->getUsername();
  return $username;
}
