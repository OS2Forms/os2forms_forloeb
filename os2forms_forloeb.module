<?php

use Drupal\webform\Entity\WebformSubmission;

/**
 * @file
 * Install, update and uninstall functions for the os2forms_forloeb_profile installation profile.
 */

/**
 * Implements hook_install().
 */
function os2forms_forloeb_install() {
  $theme_list = [
    'claro',
    'gin',
    'bootstrap',
    'custom_theme'
  ];

  // Install themes
  \Drupal::service('theme_installer')->install($theme_list);

  // Get theme manager
  $system_theme = \Drupal::configFactory()->getEditable('system.theme');

  // Set default and admin themes
  $system_theme
    ->set('default', 'custom_theme')
    ->set('admin', 'gin')
    ->save();
}

use Drupal\maestro\Engine\MaestroEngine;

/**
 * Implements hook_maestro_interactive_handlers() for the return of an Array
 * of function names and help text that will be displayed in the edit task
 * form under the handler field.
 */
function os2forms_forloeb_maestro_interactive_handlers() {
  return [
    'os2forms_forloeb_workflow_maestro_reassign_form' => t('TilfÃ¸j sagsbehandler'),
    'os2forms_forloeb_show_url_results' => t('Test URL fetch - requires process variables from that handler'),
  ];
}

/**
 * The Reassign for Approval form used in maestro workflows.
 *
 * @param array $form
 *   The array that contains the form.
 * @param int $queueID
 *   The queueID from Maestro.
 * @param object $obj
 *   References the calling object.
 */
function os2forms_forloeb_workflow_maestro_reassign_form(&$form, $queueID = 0, $obj) {

  $form['reviewer'] = array(
    '#id' => 'select_assigned_user',
    '#type' => 'entity_autocomplete',
    '#target_type' => 'user',
    '#default_value' => '',
    '#selection_settings' => ['include_anonymous' => FALSE],
    '#title' =>  t('Assign for Review to'),
  );

  $form['queueID'] = array(
    '#type' => 'hidden',
    '#title' => 'the queue ID in the event we need it in later processing',
    '#default_value' => $queueID,
    '#description' => ('queueID'),
  );

  //overriding the default label "complete"
  $form['actions']['submit']['#value'] = t('Assign');

  return $form;
}


/**
 * GIR-related utility functions START - we should probably move them to
 * a separate module as we get more of them.
 */

function get_gir_url() {

  $forloeb_configuration = \Drupal::config('os2forms_forloeb.settings');
  $gir_url = $forloeb_configuration->get('gir_url');

  return $gir_url;
}


function get_externals_parent() {

  $forloeb_configuration = \Drupal::config('os2forms_forloeb.settings');
  $gir_url = $forloeb_configuration->get('externals_root');

  return $gir_url;
}


/* Utility function for looking up the ID of a taxonomy term from the name. */

function get_term_id_by_name($name) {

  $properties = [];
  $properties['name'] = $name;
  $terms = \Drupal::entityManager()->getStorage(
    'taxonomy_term'
  )->loadByProperties($properties);
  $term = reset($terms);
  return $term->id();
}

function get_json_from_api($path) {

  $mo_url = get_gir_url();
  $auth_token = get_openid_auth_token();

  // Authenticate
  $headers = [ 'Authorization' => 'Bearer ' . $auth_token, 'Accept' => 'application/json', ];

  try {
    $response = \Drupal::httpClient()->request(
      'GET', $mo_url . $path, [
        'headers' => $headers
      ]
    );
  } catch (GuzzleHttp\Exception\BadResponseException $e) {
    $response = $e->getResponse();
  }

  if ($response->getStatusCode() == 200) {
    return json_decode($response->getBody(), true);
  }
  else {

    \Drupal::logger(
      'os2forms_forloeb'
    )->notice('Call to URL'  . $url . 'failed:' . $response->getBody());
    return "";
  }
}

function get_openid_auth_token() {
  // TODO: This is a utility token to get an OpenID Connect bearer token from Keycloak.
  // At some point, this should be moved to a "utilities" file.

  $keycloak_configuration = \Drupal::config('openid_connect.settings.keycloak');

  $keycloak_settings = $keycloak_configuration->get('settings');
  $keycloak_base = $keycloak_settings['keycloak_base'];
  $keycloak_realm = $keycloak_settings['keycloak_realm'];
  $client_id = $keycloak_settings['client_id'];
  $client_secret = $keycloak_settings['client_secret'];


  $token_url = $keycloak_base . '/realms/' . $keycloak_realm . '/protocol/openid-connect/token';

  $payload['grant_type'] = 'client_credentials';
  $payload['client_id'] = $client_id;
  $payload['client_secret'] = $client_secret;

  $json = json_encode($payload);
  $response = \Drupal::httpClient()->request(
    'POST', $token_url, [ 'form_params' => $payload ]
  );
  $status_code = $response->getStatusCode();

  if ($status_code == 200) {
    $body = json_decode($response->getBody(), true); 
    $access_token = $body['access_token'];

    return $access_token;
  } else {
    return '';	    
  }
}

function get_employees_for_org_unit($org_unit_uuid) {
  // Get all employees with engagements in this  org unit
  // NOTE: Do not recurse into children.
  $engagement_path = "/service/ou/{$org_unit_uuid}/details/engagement?validity=present";

  $engagements = get_json_from_api($engagement_path);

  $employees = [];

  foreach ($engagements as $engagement)
    $employees[$engagement['uuid']] = $engagement["person"];
  
  return $employees;

}

function get_externals_for_org_unit($org_unit_uuid) {
  $engagement_associations_path = "/api/v1/engagement_association?validity=present&org_unit={$org_unit_uuid}";
  $engagement_associations = get_json_from_api($engagement_associations_path);

  $externals = [];

  foreach ($engagement_associations as $ea) {
    if ($ea["engagement_association_type"]["user_key"] == "External") {
      $externals[$ea["engagement"]["user_key"]] = $ea["engagement"]["person"];
    }
  }

  return $externals;
}



/**
 * GIR-related utility functions END.
 */


/**
 * This is a simple batch handler to display the result
 * of calling an external URL.
 *
 * Requires two process variables, 'url_status' and 'url_body', and
 * requires the batch function calling the URL to set these variables.
 *
 * @param array $form
 *   The form you will create with this function.
 * @param int $queueID
 *   The ID of the queue task ID you are executing.
 */
function os2forms_forloeb_show_url_results(array &$form, $queueID = 0, $obj = NULL) {
  $form['queueID'] = [
    '#type' => 'hidden',
    '#title' => 'Hidden Queue ID',
    '#default_value' => $queueID,
    '#description' => ('queueID'),
  ];

  $processID = MaestroEngine::getProcessIdFromQueueId($queueID);
  $url_status = MaestroEngine::getProcessVariable('url_status', $processID);
  $url_body = MaestroEngine::getProcessVariable('url_body', $processID);
  if ($url_status === FALSE) {
    $message = 'No process variable called message defined for this workflow template';
  }

  $form['url_status'] = [
    '#plain_text' => $url_status,
    '#suffix' => '<br>',
  ];

  $form['url_body'] = [
    '#plain_text' => $url_body,
    '#suffix' => '<br>',
  ];

  return $form;
}


/**
 * This is the submit handler for the Reassign for Approval form use in maestro workflows.
 */
function os2forms_forloeb_workflow_maestro_reassign_form_submit(&$form, &$form_state) {

  $queueID = intval($form_state->getValue('queueID'));
  $processID = MaestroEngine::getProcessIdFromQueueId($queueID);

  //Who was selected? Load their username, which is the user attribute that Maestro assigns tasks by.
  $reviewer_uid = $form_state->getValue('reviewer');
  $reviewer = \Drupal\user\Entity\User::load($reviewer_uid); // pass your uid
  $reviewer_username = $reviewer->getUsername();

  //add that user to our maestro process variable.
  MaestroEngine::setProcessVariable("assigned_to", $reviewer_username, $processID);

  //Provide some feedback
  \Drupal::messenger()->addStatus("Content Reassigned");

}

/**
 *  * Implements hook_maestro_batch_handlers().
 *   *
 *    * Array of function names and help text that will be displayed
 *     * in the edit task form under the handler field.
 *      */
function os2forms_forloeb_maestro_batch_handlers() {
  return [
    'os2forms_forloeb_end_notification_batch_function' => t('Batch function to send out flow completion notification to initiator.'),
    'os2forms_forloeb_fetch_from_http_endpoint_batch_function' => t('Batch function to fetch data from an external HTTP endpoint. Returns data in two process variables, url_status and url_body.'),
    'os2forms_forloeb_gir_create_org_unit' => t('Batch function to create a new org unit in GIR.'),
    'os2forms_forloeb_gir_change_org_unit' => t('Batch function to change an org unit in GIR.'),
    'os2forms_forloeb_gir_disable_org_unit' => t('Batch function to disable an org unit in GIR.'),
    'os2forms_forloeb_gir_create_external' => t('Batch function to create a new external employee in GIR.'),
    'os2forms_forloeb_gir_change_external' => t('Batch function to change an external employee in GIR.'),
    'os2forms_forloeb_gir_disable_external' => t('Batch function to disable an external employee in GIR.'),
    'os2forms_forloeb_gir_approver_is_initiator' => t('Batch function to compare approver and initiator of a submission'),
  ];
}

/**
 *  * @param int $processID
 *   *   The Maestro process ID.
 *    * @param int $queueID
 *     *   The Maestro queue ID.
 *      */
function os2forms_forloeb_end_notification_batch_function($processID, $queueID) {

  /*
   * Pseudocode for handling this:
   *
   *     * Get entity item for webform which spawned this process
   *      (ID "submission").
   *       foreach handler in webform: {
   *           if (email_handler) {
   *               email_handler.submit();
   *           }
   *       }
   */
  $sid = MaestroEngine::getEntityIdentiferByUniqueID($processID, 'submission');

  if ($sid) {
    $webform_submission = \Drupal\webform\Entity\WebformSubmission::load($sid);
    $webform =  $webform_submission->getWebform();
    $handlers = $webform->getHandlers();

    foreach ($handlers as $handler) {
      if (method_exists($handler, 'getMessage')) {
        $message = $handler->getMessage($webform_submission);
        $handler->sendMessage($webform_submission, $message);
      }
    }
  }

  return TRUE;
}

function os2forms_forloeb_fetch_from_http_endpoint_batch_function($processID, $queueID) {

  // TODO: get URL from process variable.
  $url = MaestroEngine::getProcessVariable('url', $processID);

  $response = \Drupal::httpClient()->get($url);
  $status_code = $response->getStatusCode();
  if ($status_code == 200) {
    $body = $response->getBody();
  }
  else {
    $body = '';
  }

  MaestroEngine::setProcessVariable('url_status', $status_code, $processID);
  MaestroEngine::setProcessVariable('url_body', $body, $processID);

  return TRUE;

}

function os2forms_forloeb_gir_approver_is_initiator($processID, $queueID) {
  // Function to determine whether the initiator of this process is set as approver.
  // It would be nice to be able to handle this in an IF task, but currently Maestro's
  //  IF tasks only allows you to compare a process variable to a constant value.
  // This function will succeed if the approver is initiator and fail otherwise - this
  //  means that it can be combined with an IF task set up to branch according to the
  //  result of the preceding task.
  $initiator = MaestroEngine::getProcessVariable('initiator', $processID);
  $approver = MaestroEngine::getProcessVariable('approver', $processID);

  \Drupal::logger('os2forms_forloeb')->notice('initiator: ' . $initiator . ', approver: ' . $approver);
  if ($initiator === $approver) {
    // S'all good, man!
    return TRUE;
  } else {
    \Drupal::logger('os2forms_forloeb')->notice('Cancelling task!');
    return [ 'execution_status' => TASK_STATUS_CANCEL, 'completion_status' => MAESTRO_TASK_COMPLETION_NORMAL, 'status' => TRUE ];
  }
}


function os2forms_forloeb_gir_change_org_unit($processID, $queueID) {
  // TODO: Implement this.
  return TRUE;
}


function os2forms_forloeb_gir_change_external($processID, $queueID) {
  // TODO: Implement this.
  return TRUE;
}


function os2forms_forloeb_gir_disable_org_unit($processID, $queueID) {
  // TODO: Implement this.
  return TRUE;
}


function os2forms_forloeb_gir_disable_external($processID, $queueID) {
  // TODO: Implement this.
  return TRUE;
}


function os2forms_forloeb_gir_create_org_unit($processID, $queueID) {

  // Get GIR URL from configuration.
  $url = get_gir_url();

  $create_url = $url . '/service/ou/create';

  // Get ID for webform which spawned this process.
  $sid = MaestroEngine::getEntityIdentiferByUniqueID($processID, 'submission');
  if ($sid) {

    $webform_submission = \Drupal\webform\Entity\WebformSubmission::load($sid);
    // cf.
    // https://www.drupal.org/project/webform/issues/2911356#comment-12271553
    $values = $webform_submission->getData();

    // Org data
    $name = $values['name'];
    $parent_unit_id = get_externals_parent();
    // TODO: Handle location/address data correctly.
    $start_date = $values['start_date'];
    $_end = $values['end_date'];
    # Sending empty strings is bad
    $end_date = $_end !== '' ? $_end : null ;

    // Approval information
    $time_limit = $values['time_limit'];
    $justification = $values['justification'];
    // Extract MO UUIDs for these entities.
    $approver = $values['approver'];
    $owner = $values['owner'];

  }
  else {
    return FALSE;
  }

  # Get org unit type from data
  $ou_type_items = get_json_from_api('/service/f/org_unit_type/')['data']['items'];
  $ou_type_id = null;
  
  foreach ($ou_type_items as $item) {
    if ($item['user_key'] === 'External'){
      $ou_type_id = $item['uuid'];
      break;
    }
  }

  # TODO: Org unit level should come from user data as well 
  # since there will probably be more than one
  $ou_level_items = get_json_from_api('/service/f/org_unit_level/')['data']['items'];
  $ou_level_id = null;

  foreach ($ou_level_items as $item) {
    if ($item['user_key'] === 'L0'){
      $ou_level_id = $item['uuid'];
      break;
    }
  }

  $gir_json = [
    'name' => $name,
    'user_key' => $name,
    'validity' => ['from' => $start_date, 'to' => $end_date],
    'parent' => ['uuid' => $parent_unit_id],
    'org_unit_type' => ['uuid' => $ou_type_id],
    'org_unit_level' => ['uuid' => $ou_level_id],
  ];


  $post_data = json_encode($gir_json);

  // Get access token for authentication.
  $access_token = get_openid_auth_token();

  \Drupal::logger('os2forms_forloeb')->notice('Org Unit JSON sent: ' . '<' . $post_data . '>');
  $headers = [
    'Authorization' => 'Bearer ' . $access_token,
    'Accept' => 'application/json', 
    'content-type' => 'application/json',
  ];

  try {
    $response = \Drupal::httpClient()->request(
      'POST', $create_url, [
        'body' => $post_data,
        'headers' => $headers
      ]
    );
  } catch (GuzzleHttp\Exception\BadResponseException $e) {
    $response = $e->getResponse();
  }
  $status_code = $response->getStatusCode();
  if ($status_code == 201) {
    $url_status = "Success";
    $url_body = "Org unit " . $name . "was created.";
  } else {
    $body = $response->getBody();
    $url_status = "Failed";
    $url_body = "Unable to create org unit " . $name . ": " . $body;
  }

  MaestroEngine::setProcessVariable('url_status', $url_status, $processID);
  MaestroEngine::setProcessVariable('url_body', $url_body, $processID);

  return TRUE;

}


function os2forms_forloeb_gir_create_external($processID, $queueID) {

  // Get GIR URL from process variable.
  $url = get_gir_url();

  $create_url = $url . '/service/e/create';

  // Get ID for webform which spawned this process.
  $sid = MaestroEngine::getEntityIdentiferByUniqueID($processID, 'submission');
  if ($sid) {

    $webform_submission = \Drupal\webform\Entity\WebformSubmission::load($sid);
    // cf.
    // https://www.drupal.org/project/webform/issues/2911356#comment-12271553
    $values = $webform_submission->getData();

    // Employee Data
    $first_name = $values['first_name'];
    $last_name = $values['last_name'];
    // TODO: Format data with MO UUIDs for consultancy, consultant
    // type, cost center and org units.
    $start_date = $values['start_date'];
    $end_date = $values['end_date'];

    // Approval information
    $time_limit = $values['time_limit'];
    $justification = $values['justification'];
    // Extract MO UUIDs for these entities.
    $approver = $values['approver'];
    // $owner = $values['owner'];

  }
  else {
    return FALSE;
  }
  $gir_json = new \stdClass();
  $gir_json->givenname = $first_name;
  $gir_json->surname = $last_name;

  $gir_json->validity = new \stdClass();
  $gir_json->validity->from = $start_date;
  if ($end_date)
    $gir_json->validity->to = $end_date;

  $post_data = json_encode($gir_json);
  \Drupal::logger('os2forms_forloeb')->notice('Employee JSON sent: ' . '<' . $post_data . '>'); 

  // Get access token for authentication.
  $access_token = get_openid_auth_token();
  $headers = [
    'Authorization' => 'Bearer ' . $access_token,
    'Accept' => 'application/json', 
    'content-type' => 'application/json',
  ];

  try {
    $response = \Drupal::httpClient()->request(
      'POST', $create_url, [ 'body' => $post_data, 'headers' => $headers ]
    );
  } catch (GuzzleHttp\Exception\BadResponseException $e) {
    $response = $e->getResponse();
  }

  $status_code = $response->getStatusCode();
  if ($status_code == 201) {
    $url_status = "Success";
    $url_body = "Employee " . $first_name . " " . $last_name . " was created.";
  }
  else {
    $body = $response->getBody();
    $url_status = "Failed";
    $url_body = "Unable to create org unit " . $name . ": " . $body;
  }

  MaestroEngine::setProcessVariable('url_status', $status_code, $processID);
  MaestroEngine::setProcessVariable('url_body', $url_body, $processID);

  return TRUE;

}

/**
 * Set Process Variable (SPV) function which uses the webform's unique identifier referenced in the Maestro "webforms" process variable
 * to read a value from the webform submission and return it to the SPV task to set the process variable in the task. The function assumes that the value to be extracted is the SID of a user and returns the username instead. This seems to be the easiest way to accomplish this.
 *
 * The "webforms" process variable is set by the Maestro Webforms submission handler which sets a "submission:xxx" value in the "webforms" process variable
 * (where "xxx" is the unique ID of the submission), or is set by the Maestro Webform Task Type's "Unique Identifier" setting when editing a Maestro Webform Task.
 *
 * @param string $uniqueWebformIdentifier
 *   The webform's "Unique Identifier" as stored in the "webforms" process variable.
 * @param string $webformFieldMachineName
 *   The webform field's machine name (listed as "KEY" in the webform builder) you wish to pull the value out of.
 * @param int $queueID
 *   Provided by the executing SPV task -- the QueueID of the SPV task.
 * @param int $processID
 *   Provided by the executing SPV task -- the ProcessID of the workflow running the SPV task.
 */
function os2forms_forloeb_spv_fetch_entity_username($uniqueWebformIdentifier, $webformFieldMachineName, $queueID, $processID) {
  $returnValue = 'unset';
  // This is the submission we're eventually after.
  $sid = FALSE;
  $sid = MaestroEngine::getEntityIdentiferByUniqueID($processID, $uniqueWebformIdentifier);
  if ($sid) {
    $webform_submission = WebformSubmission::load($sid);
  }
  if ($webform_submission && array_key_exists($webformFieldMachineName, $webform_submission->getData())) {
    $returnValue = $webform_submission->getData()[$webformFieldMachineName];
  }
  // At this point, the submission's value OR 'unset' is in the $returnValue.
  if ($returnValue == 'unset' or !$returnValue) {
    return $returnValue;
  }
  $account = \Drupal\user\Entity\User::load($returnValue);
  $username = $account->getUsername();
  return $username;
}

